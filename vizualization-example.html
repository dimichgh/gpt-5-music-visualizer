<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive Crystal Sphere - Cosmic Oracle</title>
<script src="https://cdn.tailwindcss.com"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

<style>
body {
    margin: 0;
    overflow: hidden;
    background-color: #000;
    color: #e0f7fa;
    font-family: 'Orbitron', sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}
canvas {
    width: 100vw;
    height: 100vh;
    display: block;
    position: fixed;
    top: 0;
    left: 0;
    z-index: 1;
}
#starfield {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
    z-index: 0;
}
.star {
    position: absolute;
    background-color: #fff;
    border-radius: 50%;
    animation: twinkle 5s infinite ease-in-out;
    box-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #00ffff;
}
@keyframes twinkle {
    0%, 100% { opacity: 0.5; transform: scale(0.8); }
    50% { opacity: 1; transform: scale(1.2); }
}
.ui-panel {
    background: rgba(10, 25, 47, 0.7);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(0, 255, 255, 0.2);
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.15), inset 0 0 15px rgba(0, 255, 255, 0.1);
}
.glow-border {
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    animation: glow 2.5s ease-in-out infinite alternate;
}
@keyframes glow {
    from { box-shadow: 0 0 20px rgba(0, 255, 255, 0.3); }
    to { box-shadow: 0 0 35px rgba(0, 255, 255, 0.6); }
}
.loader {
    border-top-color: #00ffff;
    animation: spin 1s linear infinite;
}
@keyframes spin {
    to { transform: rotate(360deg); }
}
</style>

<div id="starfield"></div>

<div class="fixed inset-0 z-10 pointer-events-none flex flex-col justify-end p-4 md:p-8">
  <div id="ui-container" class="self-center flex flex-col items-center gap-4 pointer-events-auto">
    <button id="effect-trigger" class="group w-16 h-16 ui-panel rounded-full flex items-center justify-center transition-all duration-300 hover:scale-110 hover:border-cyan-400/80 active:scale-95 disabled:scale-100 disabled:cursor-wait disabled:bg-black/70 glow-border">
      <div id="button-content" class="transition-opacity duration-300"></div>
    </button>
  </div>
</div>

<script type="importmap">
{"imports":{
  "three":"https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
  "three/addons/":"https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
}}
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';

let scene, camera, renderer, composer, clock, filmPass, bloomPass;
let sphereGroup, crystalSphere, energyCore;
let effectState = 0, time = 0;
const effectGroups = {
  resonance: new THREE.Group(),
  prism: new THREE.Group(),
  galacticRift: new THREE.Group()
};
const effectData = {
  resonance: { isActive: false },
  prism: { isActive: false },
  galacticRift: { isActive: false, phase: 'idle', duration: 0, shake: 0 }
};

const triggerButton = document.getElementById('effect-trigger');
const buttonContent = document.getElementById('button-content');
const loadingSpinner = `<div class="loader w-8 h-8 border-4 border-cyan-200/20 rounded-full"></div>`;
const powerIcon = `<svg xmlns="http://www.w3.org/2000/svg" class="w-8 h-8 text-cyan-300 group-hover:text-white transition-colors" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M5.636 5.636a9 9 0 1012.728 0M12 3v9"/></svg>`;

const effectThemes = [
  {
    name: "Crystal Resonance", effect: "resonance",
    colors: [new THREE.Color(0x00ffff), new THREE.Color(0x00aaff), new THREE.Color(0x80aaff)],
    coreColor: new THREE.Color(0x00ffff), edgeColor: new THREE.Color(0x40a0ff)
  },
  {
    name: "Prism Flare", effect: "prism",
    colors: [new THREE.Color(0xff8080), new THREE.Color(0xffff80), new THREE.Color(0x80ff80), new THREE.Color(0x80ffff), new THREE.Color(0x8080ff), new THREE.Color(0xff80ff)],
    coreColor: new THREE.Color(0xffa0a0), edgeColor: new THREE.Color(0xffffff)
  },
  {
    name: "Galactic Rift", effect: "galacticRift",
    colors: [new THREE.Color(0x9400D3), new THREE.Color(0xff00ff), new THREE.Color(0x8A2BE2)],
    coreColor: new THREE.Color(0xdda0dd), edgeColor: new THREE.Color(0x9370DB)
  }
];

function init() {
  scene = new THREE.Scene();
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  document.body.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 12);
  clock = new THREE.Clock();

  createStarfield();
  createCrystalSphere(4, 5);
  createEnergyCore();

  sphereGroup = new THREE.Group();
  sphereGroup.add(crystalSphere.particles, crystalSphere.wireframe, energyCore);
  scene.add(sphereGroup, effectGroups.resonance, effectGroups.prism, effectGroups.galacticRift);

  composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));

  bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    1.5, 0.4, 0.85
  );
  bloomPass.threshold = 0.21;
  bloomPass.strength = 1.2;
  bloomPass.radius = 0.55;
  composer.addPass(bloomPass);

  filmPass = new FilmPass(0.2, 0.025, 648, false);
  composer.addPass(filmPass);

  setPalette(effectThemes[0]);
  updateUI();
  setupEventListeners();
  animate();
}

function createStarfield() {
  const starfield = document.getElementById('starfield');
  for (let i = 0; i < 200; i++) {
    const star = document.createElement('div');
    const size = Math.random() * 2 + 1;
    star.className = 'star';
    star.style.width = `${size}px`;
    star.style.height = `${size}px`;
    star.style.top = `${Math.random() * 100}%`;
    star.style.left = `${Math.random() * 100}%`;
    star.style.animationDelay = `${Math.random() * 5}s`;
    star.style.animationDuration = `${Math.random() * 3 + 4}s`;
    starfield.appendChild(star);
  }
}

function createCrystalSphere(radius, detail) {
  const geo = new THREE.IcosahedronGeometry(radius, detail);
  const pos = geo.attributes.position.array;
  const pPos = [], pCol = [], tw = [];
  for (let i = 0; i < pos.length; i += 3) {
    pPos.push(pos[i], pos[i+1], pos[i+2]);
    pCol.push(0.2, 0.6, 1);
    tw.push(Math.random() < 0.2 ? Math.random()*3+1 : 0);
  }
  const pg = new THREE.BufferGeometry();
  pg.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
  pg.setAttribute('color', new THREE.Float32BufferAttribute(pCol, 3));
  const pm = new THREE.PointsMaterial({
    vertexColors: true, size: 0.05, sizeAttenuation: true,
    transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false
  });
  const particles = new THREE.Points(pg, pm);
  const wm = new THREE.LineBasicMaterial({
    color: 0x4080ff, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending
  });
  const wireframe = new THREE.LineSegments(new THREE.WireframeGeometry(geo), wm);
  crystalSphere = { particles, wireframe, twinkleFactors: tw };
}

function createEnergyCore() {
  const geo = new THREE.IcosahedronGeometry(0.65, 3);
  const mat = new THREE.MeshBasicMaterial({
    color: 0xffffff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
  });
  energyCore = new THREE.Mesh(geo, mat);
}

function triggerResonance(theme) {
  if (effectGroups.resonance.children.length) return;
  effectData.resonance.isActive = true;
  for (let i = 0; i < 5; i++) {
    const g = new THREE.TorusGeometry(4.5 + i, 0.06, 16, 100);
    const m = new THREE.MeshBasicMaterial({
      color: theme.colors[i % theme.colors.length],
      transparent: true, opacity: 1, blending: THREE.AdditiveBlending,
      side: THREE.DoubleSide
    });
    const w = new THREE.Mesh(g, m);
    w.rotation.x = Math.PI/2;
    w.scale.set(0.1,0.1,0.1);
    w.userData = { life: 1, delay: i*0.1 };
    effectGroups.resonance.add(w);
  }
}

function triggerPrism(theme) {
  if (effectGroups.prism.children.length) return;
  effectData.prism.isActive = true;
  for (let i = 0; i < 150; i++) {
    const g = new THREE.CylinderGeometry(0.005, 0.005, 20, 8);
    const m = new THREE.MeshBasicMaterial({
      color: theme.colors[i % theme.colors.length],
      transparent: true, opacity: 0, blending: THREE.AdditiveBlending
    });
    const ray = new THREE.Mesh(g, m);
    const dir = new THREE.Vector3().randomDirection();
    ray.position.set(0,0,0); ray.lookAt(dir); ray.rotateX(Math.PI/2);
    ray.userData = { direction: dir, speed: 0.1 + Math.random()*0.05, life:1, phase:0 };
    effectGroups.prism.add(ray);
  }
}

function triggerGalacticRift(theme) {
  if (effectData.galacticRift.isActive) return;
  Object.assign(effectData.galacticRift, { isActive:true, phase:'imploding', duration:0 });
  const count = 5000, pos = new Float32Array(count*3), col = new Float32Array(count*3), uD = [];
  for (let i = 0; i < count; i++) {
    const c = theme.colors[i % theme.colors.length];
    col[i*3] = c.r; col[i*3+1] = c.g; col[i*3+2] = c.b;
    uD.push({
      life: 2 + Math.random()*2,
      velocity: new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5)
                 .normalize().multiplyScalar(Math.random()*10+5),
      rotationSpeed: (Math.random()-0.5)*0.02
    });
  }
  const bg = new THREE.BufferGeometry();
  bg.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
  bg.setAttribute('color', new THREE.Float32BufferAttribute(col,3));
  bg.userData = uD;
  const mat = new THREE.PointsMaterial({
    size:0.1, vertexColors:true, blending:THREE.AdditiveBlending,
    transparent:true, opacity:1, depthWrite:false
  });
  const nebula = new THREE.Points(bg, mat);
  nebula.visible = false;
  effectGroups.galacticRift.add(nebula);
}

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  time += dt;

  if (effectData.galacticRift.shake > 0) {
    effectData.galacticRift.shake -= dt;
    camera.position.x += (Math.random()-0.5)*0.2;
    camera.position.y += (Math.random()-0.5)*0.2;
  }

  camera.position.x = Math.sin(time*0.1)*12;
  camera.position.z = Math.cos(time*0.1)*12;
  camera.lookAt(scene.position);

  sphereGroup.rotation.y += 0.0005;
  energyCore.rotation.y += 0.002;
  energyCore.rotation.x += 0.003;
  if (!['imploding','exploding'].includes(effectData.galacticRift.phase)) {
    energyCore.scale.setScalar(1 + Math.sin(time*2)*0.15);
  }

  applySparkle();
  if (effectData.resonance.isActive) animateResonance(dt);
  if (effectData.prism.isActive) animatePrism(dt);
  if (effectData.galacticRift.isActive) animateGalacticRift(dt);

  checkEffectsComplete();
  composer.render();
}

function animateResonance(dt) {
  if (!effectGroups.resonance.children.length) { effectData.resonance.isActive = false; return; }
  effectGroups.resonance.children.forEach(w => {
    if (w.userData.delay > 0) { w.userData.delay -= dt; return; }
    w.userData.life -= dt * 0.5;
    const p = 1 - w.userData.life;
    w.scale.setScalar(p*2);
    w.material.opacity = Math.sin(w.userData.life * Math.PI);
  });
  effectGroups.resonance.children = effectGroups.resonance.children.filter(w => w.userData.life > 0);
}

function animatePrism(dt) {
  if (!effectGroups.prism.children.length) { effectData.prism.isActive = false; return; }
  effectGroups.prism.children.forEach(r => {
    r.userData.phase += dt * 4;
    if (r.userData.phase < 1) r.material.opacity = r.userData.phase;
    else { r.userData.life -= dt * 0.8; r.material.opacity = r.userData.life; }
  });
  effectGroups.prism.children = effectGroups.prism.children.filter(r => r.userData.life > 0);
}

function animateGalacticRift(dt) {
  const d = effectData.galacticRift;
  d.duration += dt;
  if (d.phase === 'imploding') {
    const p = Math.min(d.duration/0.5,1);
    sphereGroup.scale.setScalar(1 - p*0.99);
    if (p >= 1) { d.phase = 'exploding'; d.duration = 0; effectGroups.galacticRift.children[0].visible = true; d.shake = 0.3; }
  } else if (d.phase === 'exploding') {
    const neb = effectGroups.galacticRift.children[0];
    const posAttr = neb.geometry.attributes.position, uArr = neb.geometry.userData;
    uArr.forEach((pd, i) => {
      pd.life -= dt;
      if (pd.life > 0) {
        const vec = new THREE.Vector3(posAttr.getX(i), posAttr.getY(i), posAttr.getZ(i));
        vec.add(pd.velocity.clone().multiplyScalar(dt));
        vec.applyAxisAngle(pd.velocity, pd.rotationSpeed);
        posAttr.setXYZ(i, vec.x, vec.y, vec.z);
      }
    });
    posAttr.needsUpdate = true;
    const p2 = Math.min(d.duration,1);
    sphereGroup.scale.setScalar(0.01 + p2*0.99);
    if (d.duration > 3) d.phase = 'fading';
  } else if (d.phase === 'fading') {
    const neb = effectGroups.galacticRift.children[0];
    neb.material.opacity -= dt*2;
    if (neb.material.opacity <= 0) {
      effectGroups.galacticRift.remove(neb);
      neb.geometry.dispose();
      neb.material.dispose();
      d.isActive = false;
      d.phase = 'idle';
    }
  }
}

function applySparkle() {
  const colAttr = crystalSphere.particles.geometry.attributes.color;
  for (let i = 0; i < colAttr.count; i++) {
    if (crystalSphere.twinkleFactors[i] > 0) {
      const pulse = Math.sin(crystalSphere.twinkleFactors[i]*time + i*0.1)*0.5 + 0.5;
      const bright = 1 + pulse*2.5;
      const c = effectThemes[effectState].colors[i % effectThemes[effectState].colors.length];
      colAttr.setXYZ(i, c.r*bright, c.g*bright, c.b*bright);
    }
  }
  colAttr.needsUpdate = true;
}

function updateUI() {
  if (!triggerButton.disabled) buttonContent.innerHTML = powerIcon;
}

function setPalette(theme) {
  const colAttr = crystalSphere.particles.geometry.attributes.color;
  for (let i = 0; i < colAttr.count; i++) {
    const c = theme.colors[i % theme.colors.length];
    colAttr.setXYZ(i, c.r, c.g, c.b);
  }
  colAttr.needsUpdate = true;
  crystalSphere.wireframe.material.color.set(theme.edgeColor);
  energyCore.material.color.set(theme.coreColor);
}

function checkEffectsComplete() {
  const any = Object.values(effectData).some(d => d.isActive);
  if (!any && triggerButton.disabled) {
    triggerButton.disabled = false;
    updateUI();
  }
}

function handleTrigger() {
  triggerButton.disabled = true;
  buttonContent.innerHTML = loadingSpinner;
  const theme = effectThemes[effectState];
  setPalette(theme);
  if (theme.effect === 'resonance') {
    triggerResonance(theme);
    bloomPass.strength = 1.5;
    setTimeout(() => bloomPass.strength = 1.2, 1500);
  } else if (theme.effect === 'prism') {
    triggerPrism(theme);
    bloomPass.strength = 1.6;
    setTimeout(() => bloomPass.strength = 1.2, 2500);
  } else {
    triggerGalacticRift(theme);
    bloomPass.strength = 2.5;
    setTimeout(() => bloomPass.strength = 1.2, 3500);
  }
  effectState = (effectState + 1) % effectThemes.length;
}

function setupEventListeners() {
  triggerButton.addEventListener('click', handleTrigger);
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  });
}

init();
</script>
